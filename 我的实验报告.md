# OpenHarmony 嵌入式系统原理与应用实验报告

## 课题名称
智慧农业物联网系统（MQTT + Flask + MySQL）

## 学生信息
- 姓名：__________
- 学号：__________
- 学院：__________
- 专业：__________

## 目录
1. 实验目标与总体方案
2. 设备端 MQTT 通信与传感器数据上报
   2.1 Wi-Fi 与 MQTT 连接配置
   2.2 主题规划与数据格式
   2.3 指令订阅与外设控制
   2.4 实验现象记录（设备端）
3. 服务端架构与数据流转
   3.1 MQTT 订阅与数据解析
   3.2 设备状态缓存与多设备支持
   3.3 控制指令下发流程
4. MySQL 数据库设计与历史数据查询
   4.1 数据库与表结构设计
   4.2 服务端入库逻辑
   4.3 历史数据查询接口
5. 前端展示与交互设计
   5.1 设备列表与实时监控
   5.2 控制按钮与状态反馈
   5.3 历史曲线与模式切换
   5.4 实验现象记录（Web 前端）
6. 实验结果与总结

---

## 1. 实验目标与总体方案

本实验目标是构建一套“设备端采集 + MQTT 传输 + 服务端解析入库 + Web 可视化”的智慧农业物联网系统。系统由以下部分组成：

- **设备端（OpenHarmony/RK2206）**：读取温湿度、光照等传感器数据，并通过 MQTT 定期上报；同时订阅控制主题，收到“灯光开关”指令后驱动外设执行。设备端核心逻辑在 `iot_mqtt.c` 中实现，包含 Wi-Fi 配置、MQTT 连接、订阅回调与数据上报流程。
- **服务端（Flask + Paho MQTT + MySQL）**：订阅多设备上报主题，对 JSON 数据解析并写入 MySQL 数据库，同时对外提供 Web API 供前端查询与控制。核心逻辑在 `server.py` 中实现，包括 MQTT 回调、数据库写入与 HTTP 接口。
- **前端展示（Vue + ECharts）**：通过轮询接口展示多设备实时数据与历史曲线，并提供灯光控制按钮。页面与交互逻辑在 `index.html` 中实现。

本实验不使用 Docker，而是直接在本机环境中配置 MQTT Broker 与 MySQL 数据库，并通过 Python 运行 Flask 服务。

---

## 2. 设备端 MQTT 通信与传感器数据上报

### 2.1 Wi-Fi 与 MQTT 连接配置
设备端在 `iot_mqtt.c` 中定义了路由器的 SSID 和密码，通过 `set_wifi_config_route_ssid` 与 `set_wifi_config_route_passwd` 配置 Wi-Fi；随后调用 `SetWifiModeOn()` 使能 Wi-Fi，并在 `NetworkInit` 与 `NetworkConnect` 中建立到 MQTT Broker 的 TCP 连接。MQTT Broker 地址和端口由宏 `MQTT_SERVER_IP` 和 `MQTT_SERVER_PORT` 指定。

为避免阻塞式 socket 导致指令无法及时接收，程序将 socket 设置为非阻塞模式，这一点在 `lwip_ioctl` 中完成，并在主循环里通过 `MQTTYield` 维持连接与接收回调处理。

**设备端 Wi-Fi 与 MQTT 连接代码（摘录）：**

```c
printf("Set WIFI\n");
set_wifi_config_route_ssid(printf,   ROUTE_SSID);
set_wifi_config_route_passwd(printf, ROUTE_PASSWORD);
printf("Set Wifi OK\n");

SetWifiModeOn();

printf("NetworkInit...\n");
NetworkInit(&network);

printf("NetworkConnect... IP: %s, Port: %d\n", MQTT_SERVER_IP, MQTT_SERVER_PORT);
rc = NetworkConnect(&network, MQTT_SERVER_IP, MQTT_SERVER_PORT);

int nb = 1;
if (lwip_ioctl(network.my_socket, FIONBIO, &nb) != 0) {
    printf("set nonblocking failed, errno=%d\n", errno);
}

printf("MQTTClientInit...\n");
MQTTClientInit(&client, &network, 2000, sendBuf, sizeof(sendBuf), readBuf, sizeof(readBuf));
```

### 2.2 主题规划与数据格式
设备端将数据发布到 `MQTT_TOPIC_PUB`，订阅指令主题 `MQTT_TOPIC_SUB`。当前工程中定义了 `liteos/dev002/data` 作为上报主题，`liteos/dev002/cmd` 作为控制主题。通过这种“设备 ID + 功能”的主题规划，可以在服务端使用通配符订阅所有设备数据。

数据上报内容由 `sprintf` 生成 JSON 字符串，仅包含温度与湿度字段：

```json
{"temperature": 25.3, "humidity": 61.0}
```

对应设备端代码：

```c
e53_ia_read_data(&data_env);

temperature = data_env.temperature;
humidity = data_env.humidity;

memset(payload, 0, sizeof(payload));
sprintf(payload, "{\"temperature\": %.1f, \"humidity\": %.1f}", temperature, humidity);

message.qos = 1;
message.retained = 0;
message.payload = payload;
message.payloadlen = strlen(payload);

if ((rc = MQTTPublish(&client, MQTT_TOPIC_PUB, &message)) != 0){
    printf("Return code from MQTT publish is %d\n", rc);
    NetworkDisconnect(&network);
    MQTTDisconnect(&client);
    goto begin;
}
```

### 2.3 指令订阅与外设控制
设备端通过 `MQTTSubscribe` 订阅控制主题，并指定 `message_receive` 作为回调函数。在回调中读取 payload，判断是否为 `light_on` 或 `light_off`，并调用 `light_set(ON/OFF)` 控制外设灯光，实现“服务端下发指令 -> 设备端执行”的闭环控制。

**指令回调代码（摘录）：**

```c
void message_receive(MessageData* data)
{
    char payload_str[100] = {0};
    if (data->message->payloadlen >= sizeof(payload_str)) {
        printf("Payload too long, ignore.\n");
        return;
    }

    memcpy(payload_str, data->message->payload, data->message->payloadlen);
    payload_str[data->message->payloadlen] = '\0';

    int len = strlen(payload_str);
    if (len > 0 && (payload_str[len-1] == '\n' || payload_str[len-1] == '\r')) {
        payload_str[len-1] = '\0';
    }
    len = strlen(payload_str);
    if (len > 0 && (payload_str[len-1] == '\n' || payload_str[len-1] == '\r')) {
        payload_str[len-1] = '\0';
    }

    if (strcmp(payload_str, "light_on") == 0) {
        printf("Command Received: Turn ON LED\n");
        light_set(ON);
    } else if (strcmp(payload_str, "light_off") == 0) {
        printf("Command Received: Turn OFF LED\n");
        light_set(OFF);
    } else {
        printf("Unknown command: %s\n", payload_str);
    }
}
```

为了保证控制指令能够及时处理，主循环不再长时间休眠，而是用 `MQTTYield(&client, 100)` 每 100ms 处理一次网络事件，再以计数器实现 2 秒一次的上报频率。

**上报节奏控制代码（摘录）：**

```c
int loop_cnt = 0;

while (1)
{
    MQTTYield(&client, 100);

    loop_cnt++;
    if (loop_cnt < 20) {
        continue;
    }

    loop_cnt = 0;

    // 读取数据并上报
    e53_ia_read_data(&data_env);
    // ... 省略打包与发送 ...
}
```

### 2.4 实验现象记录（设备端）
（此处留空，插入设备端烧录与串口日志截图、传感器读数截图）

- 设备端上电与 Wi-Fi 连接日志截图：
  - 【请在此处插入图片】
- MQTT 连接成功与订阅日志截图：
  - 【请在此处插入图片】
- 设备端接收 `light_on/light_off` 指令截图：
  - 【请在此处插入图片】

---

## 3. 服务端架构与数据流转

### 3.1 MQTT 订阅与数据解析
服务端使用 Paho MQTT 创建客户端，在 `on_connect` 中订阅主题 `liteos/+/data`。`+` 通配符允许一次性接收所有设备的数据，从而支持多设备同时在线。

**MQTT 连接与订阅代码（摘录）：**

```python
def on_connect(client, userdata, flags, rc):
    print(f"MQTT Connected code {rc}")
    client.subscribe(MQTT_TOPIC_SUB_PATTERN)

mqtt_client = mqtt.Client()
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message
mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
mqtt_client.loop_forever()
```

在 `on_message` 中解析 `msg.topic` 与 `msg.payload`：
- 使用 `topic.split('/')` 从 `liteos/dev001/data` 中提取设备 ID。
- 使用 `json.loads` 解析 payload 中的温湿度数据。
- 将解析结果更新至内存缓存，并启动线程写入 MySQL。

**MQTT 数据解析代码（摘录）：**

```python
def on_message(client, userdata, msg):
    try:
        topic = msg.topic
        payload = msg.payload.decode()
        data = json.loads(payload)

        parts = topic.split('/')
        if len(parts) >= 3:
            device_id = parts[1]
        else:
            device_id = "unknown"

        temp = data.get("temperature", 0)
        hum = data.get("humidity", 0)

        if device_id not in devices_store:
            devices_store[device_id] = {"light_on": False}

        devices_store[device_id]["temperature"] = temp
        devices_store[device_id]["humidity"] = hum

        threading.Thread(target=save_to_mysql, args=(device_id, temp, hum)).start()

    except Exception as e:
        print(f"消息处理错误: {e}")
```

### 3.2 设备状态缓存与多设备支持
服务端用 `devices_store` 字典维护多设备状态：键为设备 ID，值包含温度、湿度与灯光状态。若设备首次出现，先初始化 `light_on` 状态，再补充温湿度数据，实现“设备自动注册”。该缓存直接暴露给前端接口 `/api/devices`，前端可轮询此接口实时获取最新设备状态，无需每次访问数据库，提高响应速度。

**设备列表接口代码（摘录）：**

```python
@app.route('/api/devices')
def get_devices():
    return jsonify(devices_store)
```

### 3.3 控制指令下发流程
前端调用 `/api/control` 提交 `device_id` 与 `action`。服务端根据 action 拼装 `light_on` / `light_off` 指令，并发布到 `liteos/{device_id}/cmd`。发布成功后同步更新 `devices_store` 中的 `light_on` 状态，使前端按钮与设备状态保持一致。

**指令下发代码（摘录）：**

```python
@app.route('/api/control', methods=['POST'])
def control_device():
    req = request.get_json()
    device_id = req.get('device_id')
    action = req.get('action')

    if not device_id or device_id not in devices_store:
        return jsonify({"status": "error", "message": "设备不存在"}), 404

    topic_cmd = f"liteos/{device_id}/cmd"
    cmd_payload = "light_on" if action == "on" else "light_off"

    if mqtt_client:
        mqtt_client.publish(topic_cmd, cmd_payload)
        devices_store[device_id]['light_on'] = (action == "on")
        return jsonify({"status": "success"})
    else:
        return jsonify({"status": "error", "message": "MQTT未连接"}), 500
```

---

## 4. MySQL 数据库设计与历史数据查询

### 4.1 数据库与表结构设计
服务端配置 MySQL 连接信息并指定数据库名 `liteos_iot`。实际表结构需包含 `device_id`、`temperature`、`humidity`、`created_at` 等字段，用于记录多设备的历史数据。

```sql
CREATE DATABASE liteos_iot;

CREATE TABLE sensor_records (
  id INT PRIMARY KEY AUTO_INCREMENT,
  device_id VARCHAR(32) NOT NULL,
  temperature FLOAT NOT NULL,
  humidity FLOAT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 4.2 服务端入库逻辑
每当 MQTT 收到数据，服务端启动线程调用 `save_to_mysql`。函数使用 `pymysql.connect` 建立连接，并执行 `INSERT INTO sensor_records (device_id, temperature, humidity)`，确保每条数据都附带设备 ID，实现多设备历史数据区分。

**MySQL 入库代码（摘录）：**

```python
def save_to_mysql(device_id, temp, hum):
    conn = pymysql.connect(
        host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME,
        charset='utf8mb4', cursorclass=pymysql.cursors.DictCursor
    )
    with conn.cursor() as cursor:
        sql = "INSERT INTO sensor_records (device_id, temperature, humidity) VALUES (%s, %s, %s)"
        cursor.execute(sql, (device_id, temp, hum))
    conn.commit()
    conn.close()
```

### 4.3 历史数据查询接口
服务端提供 `/api/history` 接口，接收 `device_id` 与日期参数。SQL 使用 `DATE(created_at)` 过滤当日数据，并用 `DATE_FORMAT` 输出时间字符串，最终返回 `times` 和 `temps` 数组供 ECharts 绘图。

**历史查询接口代码（摘录）：**

```python
@app.route('/api/history')
def get_history():
    device_id = request.args.get('device_id')
    date_str = request.args.get('date')

    conn = pymysql.connect(
        host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME,
        charset='utf8mb4', cursorclass=pymysql.cursors.DictCursor
    )
    with conn.cursor() as cursor:
        sql = """
            SELECT temperature, DATE_FORMAT(created_at, '%%H:%%i:%%s') as time_str
            FROM sensor_records
            WHERE DATE(created_at) = %s AND device_id = %s
            ORDER BY created_at ASC
        """
        cursor.execute(sql, (date_str, device_id))
        results = cursor.fetchall()
        return jsonify({
            "times": [r['time_str'] for r in results],
            "temps": [r['temperature'] for r in results]
        })
```

---

## 5. 前端展示与交互设计

### 5.1 设备列表与实时监控
前端通过 Vue 维护 `devices` 数据结构，页面顶部提供设备下拉选择框，动态展示设备 ID 和灯光状态。当 `currentDeviceId` 被选择后，页面展示温度与湿度卡片，并使用 ECharts 绘制实时曲线。

**设备下拉与实时数据显示代码（摘录）：**

```html
<select class="form-select w-auto" v-model="currentDeviceId" @change="handleDeviceChange">
    <option v-for="(data, devId) in devices" :value="devId" :key="devId">
        {{ devId }} ({{ data.light_on ? '灯亮' : '灯灭' }})
    </option>
</select>

<span v-if="Object.keys(devices).length === 0" class="text-danger">
    暂无设备在线 (请检查开发板是否已连接 WiFi 并发送数据)
</span>
```

```javascript
fetchDevices() {
    axios.get('/api/devices').then(res => {
        this.devices = res.data;
        const ids = Object.keys(this.devices);

        if (!this.currentDeviceId && ids.length > 0) {
            this.currentDeviceId = ids[0];
            this.chartDataTime = [];
            this.chartDataTemp = [];
        }

        if (this.currentDeviceId && this.viewMode === 'realtime') {
            this.updateRealtimeChart();
        }
    }).catch(err => console.error("API请求失败:", err));
}
```

### 5.2 控制按钮与状态反馈
页面提供灯光控制按钮，依据 `light_on` 状态切换颜色与文字。点击按钮后调用 `/api/control`，并在请求过程中设置 `isLoading` 禁用按钮，避免重复发送指令。

**控制按钮与调用代码（摘录）：**

```html
<button class="btn btn-lg w-100"
    :class="devices[currentDeviceId].light_on ? 'btn-danger' : 'btn-success'"
    @click="toggleLight" :disabled="isLoading">
    {{ devices[currentDeviceId].light_on ? '关闭灯光' : '开启灯光' }}
</button>
```

```javascript
toggleLight() {
    if (!this.currentDeviceId) return;
    this.isLoading = true;

    const currentStatus = this.devices[this.currentDeviceId].light_on;
    const targetAction = currentStatus ? 'off' : 'on';

    axios.post('/api/control', {
        device_id: this.currentDeviceId,
        action: targetAction
    })
    .catch(err => {
        alert("控制失败: " + err);
    })
    .finally(() => {
        setTimeout(() => this.isLoading = false, 500);
    });
}
```

### 5.3 历史曲线与模式切换
前端提供“实时监控/历史回放”切换，历史模式下允许选择日期并调用 `/api/history`。返回数据后更新图表标题与曲线，若无数据则提示用户。

**历史模式查询代码（摘录）：**

```javascript
fetchHistoryData() {
    if (!this.currentDeviceId || !this.chartInstance) return;

    this.chartInstance.showLoading();
    axios.get('/api/history', {
        params: {
            date: this.selectedDate,
            device_id: this.currentDeviceId
        }
    })
    .then(res => {
        this.chartInstance.hideLoading();
        const times = res.data.times;
        const temps = res.data.temps;

        if (!times || times.length === 0) {
            alert("该设备在 " + this.selectedDate + " 没有历史数据");
            return;
        }
        this.chartInstance.setOption({
            title: { text: `${this.currentDeviceId} - ${this.selectedDate} 历史回放` },
            xAxis: { data: times },
            series: [{ data: temps }]
        });
    })
    .catch(err => {
        this.chartInstance.hideLoading();
        alert("查询失败，请检查后端日志");
    });
}
```

### 5.4 实验现象记录（Web 前端）
（此处留空，插入 Web 端实时监控截图与历史曲线截图）

- 设备列表与实时数据页面截图：
  - 【请在此处插入图片】
- 灯光控制按钮执行结果截图：
  - 【请在此处插入图片】
- 历史数据回放曲线截图：
  - 【请在此处插入图片】

---

## 6. 实验结果与总结

本实验通过 MQTT 完成设备端数据采集与控制指令下发；服务端通过 Paho MQTT 订阅与 Flask API 接口提供数据查询与控制；MySQL 实现历史数据持久化；前端通过 Vue + ECharts 实现实时监控与历史回放。系统核心链路为：

- 设备端读取传感器 -> MQTT 上报 `liteos/{device_id}/data`
- 服务端解析数据 -> 内存缓存 + MySQL 入库
- 前端实时轮询展示 -> 控制按钮发送指令
- 服务端发布 `liteos/{device_id}/cmd` -> 设备端执行灯光控制

该设计实现了“多设备监控 + 远程控制 + 历史查询”的完整闭环，为后续扩展更多传感器或控制设备提供了稳定框架基础。
