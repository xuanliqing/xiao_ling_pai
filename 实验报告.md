# 小凌派-RK2206 MQTT 物联网实验报告

## 一、实验概述
本实验基于仓库中的嵌入式端（RK2206 开发板）与服务器端（Flask + MQTT + MySQL + 前端大屏）代码，构建“设备采集数据—MQTT 发布—服务器订阅入库—Web 可视化与控制”的完整物联网链路。系统支持多设备主题订阅、实时数据展示、历史回放与设备控制指令下发。实验的核心是验证 MQTT 发布/订阅机制在资源受限设备与 Web 监控中心之间的数据通信能力，并在后端实现持久化与多设备管理。

## 二、实验目的
1. 熟悉 MQTT 发布/订阅模式在嵌入式设备与服务器之间的通信流程。
2. 掌握开发板侧网络连接、MQTT 客户端初始化、订阅与上报数据的流程。
3. 设计服务器端 MQTT 订阅与数据解析逻辑，实现多设备数据缓存与数据库持久化。
4. 搭建 Web 端监控页面，实现实时数据可视化、历史查询与设备控制。
5. 形成端到端闭环（设备采集 → 上报 → 存储 → 展示 → 控制回路）。

## 三、实验原理
### 3.1 MQTT 发布/订阅模型
MQTT 采用轻量级发布/订阅机制。设备端作为发布者向特定 Topic（如 `liteos/dev002/data`）发送 JSON 数据；服务器作为订阅者通过通配符 `liteos/+/data` 订阅所有设备的数据。控制指令反向通过 `liteos/<device_id>/cmd` 主题下发给设备端，设备端订阅该主题并执行相应操作（如开关灯）。该机制避免了设备与服务器端的强耦合，利于多设备扩展。

### 3.2 嵌入式端工作流程
1. 配置 WiFi 连接参数并连接路由器。
2. 初始化网络与 MQTT 客户端，连接服务器。
3. 订阅控制 Topic（`liteos/<device_id>/cmd`），处理下发指令。
4. 周期性读取环境传感器数据（温湿度、光照等），封装为 JSON 并发布到 `liteos/<device_id>/data`。
5. 在循环中调用 `MQTTYield` 确保接收消息不阻塞。

### 3.3 服务器端工作流程
1. 使用 `paho-mqtt` 连接 MQTT Broker 并订阅 `liteos/+/data`。
2. 接收并解析 JSON 数据，从 Topic 中提取 `device_id`。
3. 更新全局设备状态缓存 `devices_store`。
4. 将数据写入 MySQL（表 `sensor_records`）以支持历史查询。
5. 提供 REST API：
   - `/api/devices` 返回实时状态
   - `/api/control` 发布控制指令
   - `/api/history` 查询历史温度曲线

### 3.4 Web 端原理
前端使用 Vue + Axios + ECharts：
1. 轮询 `/api/devices` 获取实时数据并更新界面。
2. 在实时模式下刷新曲线；在历史模式下调用 `/api/history` 展示温度随时间变化趋势。
3. 控制按钮调用 `/api/control` 下发灯光开关指令。

## 四、系统架构与数据流
```
[RK2206 设备端] --(MQTT 发布 liteos/<id>/data)--> [MQTT Broker]
                                     |                          |
                                     | (订阅 liteos/+/data)      |
                                     v                          |
                              [Flask 服务端] ----> [MySQL]
                                     |
                                     v
                              [Web 前端可视化]

[Web 前端控制] --(POST /api/control)--> [Flask] --(MQTT 发布 liteos/<id>/cmd)--> [设备端]
```

## 五、关键代码解析
### 5.1 设备端：MQTT 连接与循环机制
**文件：`d1_iot_mqtt/iot_mqtt.c`**
- 配置 WiFi 与 MQTT 服务器地址，初始化网络。
- 将 socket 设为非阻塞，并通过 `MQTTYield` 实现短周期监听，避免 `sleep` 阻塞导致无法接收控制指令。

关键片段（截取核心逻辑）：
```c
set_wifi_config_route_ssid(printf, ROUTE_SSID);
set_wifi_config_route_passwd(printf, ROUTE_PASSWORD);
SetWifiModeOn();
NetworkInit(&network);
rc = NetworkConnect(&network, MQTT_SERVER_IP, MQTT_SERVER_PORT);
MQTTClientInit(&client, &network, 2000, sendBuf, sizeof(sendBuf), readBuf, sizeof(readBuf));
MQTTSubscribe(&client, MQTT_TOPIC_SUB, 2, message_receive);
MQTTYield(&client, 100);
```
该段代码完成 WiFi 配置、网络初始化、MQTT 客户端初始化、订阅控制主题，并在循环中通过 `MQTTYield` 处理输入消息，实现非阻塞式监听与定期上报的组合。

### 5.2 设备端：传感器上报与 JSON 构造
- 读取传感器值后构造 JSON 字符串作为 MQTT Payload。
```c
e53_ia_read_data(&data_env);
sprintf(payload, "{\"temperature\": %.1f, \"humidity\": %.1f}", temperature, humidity);
MQTTPublish(&client, MQTT_TOPIC_PUB, &message);
```
此处将温湿度封装为 JSON 发送，便于服务器端 JSON 解析。

### 5.3 设备端：控制指令解析
- 在 `message_receive` 中解析指令字符串（`light_on` / `light_off`），并控制硬件。
```c
if (strcmp(payload_str, "light_on") == 0) {
    light_set(ON);
} else if (strcmp(payload_str, "light_off") == 0) {
    light_set(OFF);
}
```
该逻辑实现由服务器端触发的远程灯光控制。

### 5.4 服务器端：MQTT 订阅与多设备状态管理
**文件：`服务端代码/server.py`**
- 使用通配符订阅多设备数据，解析 Topic 得到设备 ID，并更新全局 `devices_store`。
```python
MQTT_TOPIC_SUB_PATTERN = "liteos/+/data"

def on_message(client, userdata, msg):
    topic = msg.topic
    data = json.loads(msg.payload.decode())
    device_id = topic.split('/')[1]
    if device_id not in devices_store:
        devices_store[device_id] = {"light_on": False}
    devices_store[device_id]["temperature"] = data.get("temperature", 0)
    devices_store[device_id]["humidity"] = data.get("humidity", 0)
```
该设计实现了多设备数据的统一管理，并可扩展到更多设备。

### 5.5 服务器端：控制指令下发
- Web 端请求 `/api/control` 后，服务端向指定 Topic 发布控制消息。
```python
topic_cmd = f"liteos/{device_id}/cmd"
cmd_payload = "light_on" if action == "on" else "light_off"
mqtt_client.publish(topic_cmd, cmd_payload)
```
此处构成控制闭环：Web → MQTT → 设备。

### 5.6 前端：实时数据与历史曲线
**文件：`服务端代码/templates/index.html`**
- 前端轮询 `/api/devices`，更新设备实时数据；历史模式下调用 `/api/history`。
```javascript
axios.get('/api/devices').then(res => { this.devices = res.data; });
axios.get('/api/history', { params: { date: this.selectedDate, device_id: this.currentDeviceId } });
```
通过 ECharts 绘制实时曲线或历史曲线，支持设备切换。

### 5.7 测试数据生成脚本（可选）
**文件：`服务端代码/fake.py`**
- 通过模拟多设备随机数据发布，便于在无硬件情况下测试服务器端与前端逻辑。
```python
DEVICE_IDS = ["dev001", "dev003", "dev004"]
client.publish(f"liteos/{dev}/data", str(payload).replace("'", '"'))
```

## 六、实验步骤（结合仓库内容整理）
1. **配置设备端 WiFi 和 MQTT 服务器**：
   - 在 `iot_mqtt.c` 中设置路由器 SSID、密码与 MQTT 服务器地址端口。
2. **编译烧录设备端程序**：
   - 按照开发板环境完成编译与烧写。
3. **启动 MQTT Broker**：
   - 在服务器或本地启动 mosquitto（或其他 Broker）。
4. **启动服务端**：
   - 运行 `server.py`，服务端启动后监听 HTTP 5000 端口。
5. **打开浏览器**：
   - 访问 `http://localhost:5000`，进入多设备监控页面。
6. **观察实时数据与历史曲线**：
   - 实时模式查看温度变化；历史模式选择日期查询。
7. **执行设备控制**：
   - 在页面点击灯光控制按钮，观察设备端响应。

## 七、实验结果
1. **设备端**：串口日志显示成功连接 WiFi、MQTT 服务器，并循环上报数据；当服务器下发 `light_on` / `light_off` 时，设备端执行对应控制。
2. **服务器端**：控制台打印收到的设备数据并写入数据库，`devices_store` 能显示多设备状态。
3. **前端页面**：
   - 可选择不同设备进行监控。
   - 实时模式下曲线动态更新。
   - 历史模式下可查询指定日期温度变化。
   - 控制按钮能改变设备灯光状态。

## 八、实验分析与总结
### 8.1 系统优点
- **轻量化通信**：MQTT 协议适合嵌入式设备，降低网络与资源开销。
- **多设备扩展**：Topic 中嵌入设备 ID，服务器端采用通配符订阅实现自动扩展。
- **闭环控制**：支持从 Web 端到设备的指令下发，实现监控与控制一体化。
- **数据可视化**：前端实时曲线 + 历史回放增强可观测性。

### 8.2 可能的问题与改进方向
1. **安全性不足**：当前使用匿名 MQTT，无鉴权与 TLS；建议引入用户名密码或证书认证。
2. **数据格式健壮性**：设备端采用字符串 JSON 拼接，建议引入更严格的 JSON 库或校验逻辑。
3. **异常处理**：MQTT 断开重连逻辑可进一步完善，如采用指数回退。
4. **数据库性能**：多设备高频写入时需考虑批量写入或消息队列。
5. **前端性能**：实时数据量大时需考虑滚动窗口或数据采样策略。

### 8.3 总结
通过本实验，完成了从嵌入式设备采集、MQTT 发布/订阅、服务器存储分析到 Web 可视化控制的全链路实现，验证了 MQTT 在 IoT 场景下的高效性与可扩展性。该系统具备进一步扩展到更多传感器与控制功能的基础，为后续智能农业、智能家居等应用提供了可复用的技术框架。
